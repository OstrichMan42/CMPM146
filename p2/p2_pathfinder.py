# Collaborated with Ishmael Chavesfrom heapq import heappop, heappushimport mathdef find_path(source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    srcBox = 0    destBox = 0    print(source_point)    print(destination_point)    # Find the boxes containing the end points    for box in mesh["boxes"]:        if box[0] < source_point[0] < box[1] and box[2] < source_point[1] < box[3]:            srcBox = box            boxes[srcBox] = 0            # print("ding!")        if box[0] < destination_point[0] < box[1] and box[2] < destination_point[1] < box[3]:            destBox = box            # print("dong")        if srcBox != 0 and destBox != 0:            break    if srcBox == 0 or destBox == 0:        print("can't find box around endpoint", srcBox, destBox)        return path, boxes.keys()    # Dijkstra    queue = []    heappush(queue, (0, srcBox))    # heappush(queue, (0, destBox))    print(queue)    found = False    detailPoints = {srcBox: source_point}    while queue:        dist, currentBox = heappop(queue)        myPoint = detailPoints[currentBox]        # if currentBox == destBox:        #    myPoint = destination_point        for adj in mesh["adj"][currentBox]:            if adj == destBox:                print("found you")                found = True            if adj not in boxes:                boxes[adj] = currentBox                # calculate detail points                # calculating the x range                xLeft = {currentBox[0], adj[0]}                xRight = {currentBox[1], adj[1]}                xRange = (max(xLeft), min(xRight))                # calculating the y range                yLeft = {currentBox[2], adj[2]}                yRight = {currentBox[3], adj[3]}                yRange = (max(yLeft), min(yRight))                endPoint = [max(min(xRange[1], myPoint[0]), xRange[0]), max(min(yRange[1], myPoint[1]), yRange[0])]                length = EuclidianDist(endPoint, myPoint)                detailPoints[adj] = endPoint  # save endpoint                if currentBox == srcBox:                    detailPoints[srcBox] = endPoint                heappush(queue, (dist + length, adj))                print(queue)        if found:            break    if not found:        print("No path found")    # Path making    temp = destBox  # (x1.x2.y1.y2)    trail = boxes[temp]    # calculating the x range    # xLeft = {temp[0], trail[0]}    # xRight = {temp[1], trail[1]}    # xRange = (max(xLeft), min(xRight))    #    # calculating the y range    # yLeft = {temp[2], trail[2]}    # yRight = {temp[3], trail[3]}    # yRange = (max(yLeft), min(yRight))    #    # endPoint = [0, 0]    # bestEndPoint = [0, 0]    # bestLength = math.inf    # for x in xRange:    #     endPoint[0] = x    #     for y in yRange:    #         endPoint[1] = y    #         length = math.pow((destination_point[0] - endPoint[0]), 2) + math.pow((destination_point[1] - endPoint[1]), 2)    #    #         if length < math.pow(bestLength, 2):    #             bestEndPoint = endPoint    #             bestLength = math.sqrt(length)    # path.append((destination_point, (bestEndPoint[0], bestEndPoint[1])))    #    # lastEndPoint = bestEndPoint    path.append((destination_point, detailPoints[destBox]))    path.append((source_point, detailPoints[srcBox]))    while trail != 0:        endPoint = [0, 0]        # # calculating the x range        # xLeft = {temp[0], trail[0]}        # xRight = {temp[1], trail[1]}        # xRange = (max(xLeft), min(xRight))        #        # # calculating the y range        # yLeft = {temp[2], trail[2]}        # yRight = {temp[3], trail[3]}        # yRange = (max(yLeft), min(yRight))        #        # bestLength = math.inf        # for x in xRange:        #     endPoint[0] = x        #     for y in yRange:        #         endPoint[1] = y        #         length = math.pow((lastEndPoint[0] - endPoint[0]), 2) + math.pow((lastEndPoint[1] - endPoint[1]), 2)        #        #         if length < math.pow(bestLength, 2):        #             bestEndPoint = endPoint        #             bestLength = math.sqrt(length)        # path.append(((lastEndPoint[0], lastEndPoint[1]), (bestEndPoint[0], bestEndPoint[1])))        # lastEndPoint = bestEndPoint        path.append((detailPoints[temp], detailPoints[trail]))        temp = trail        trail = boxes[temp]    path.append((detailPoints[srcBox], source_point))    path.reverse()    return path, boxes.keys()def EuclidianDist(point1, point2):    return math.sqrt(math.pow((point1[0] - point2[0]), 2) + math.pow((point1[1] - point2[1]), 2))